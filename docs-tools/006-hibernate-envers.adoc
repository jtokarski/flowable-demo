
== Background

=== Foreword

* initially I wanted to import dependency of `org.defendev.easygo:database` to this project and make
  research starting with pre-existing tables. But since I've discovered that Hibernate schema tooling
  offers possibility to *write DDL to script* instead of making live update, I decided to only use this.
  See `JAKARTA_HBM2DDL_SCRIPTS_ACTION` / `jakarta.persistence.schema-generation.scripts.action`

* so the main focus is *generating DDLs* from Java `@Entity` classes

* validating the database schema is secondary focus. The only goal here is to prove that
  *Envers adds its own comprehensive validations* on top of pure-Hibernate validations. When that's confirmed,
  I will know that in real projects I can write DDLs manually and use Hibernate+Envers schema validation
  as guardrail (rather than generator).

=== Use case of Hibernate Envers

I realize, that for my use of Envers is implementing the *maker-checker* process, which
is not the original purpose of Envers. This comes with some major consequences:

* the normal querying for entities *goes obsolete*. Now for all tables where I show live-version data
  for the user I have to use `AuditReader` / `AuditQuery`

* it's questionable if it still makes sense have `@CreatedDate` / `@LastModifiedDate` on the `@Entity`.
  They seem redundant because Envers already tracks the same information in `@RevisionEntity`
  and audit tables.

I recall following issues with Envers-based maker-checker implemented for Ycorpo project:

* an `@Entity` was always in state of most recent update, which may be live or pending change.
  Therefore, querying, listing, sorting, pagination of live version involved revision queries.

* the *reject changes* functionality involved restoring previous revision, which
  wasn't trivial to find and apply the diff. It also felt a little unreliable - instead
  of just discarding changes we were really reproducing recent live state. It would be better
  if a live `@Entity` wasn't touched at all.

* in case of editing `@Entity` - only one working copy is possible

* showing approved changes (diff) in audit view was not trivial

* multiple changes between live versions created multi-revision gaps. We needed to handle this complexity.

* and above it all - the dynamic attribute concept with some design mistake introduced additional complexity

=== Thoughts on approach

* write multiple persistence units with isolated configuration in this single Gradle subproject

* I would like to risk to go without `@CreatedDate` / `@LastModifiedDate` fields on the `@Entity`
  and personally experience potential consequences.



== Observed features

=== General Envers principle

As described in `Hibernate_User_Guide.html`, adding Envers does not affect:

* schema of "_main_" tables

* the data persisted in "_main_" tables

I would like to catch any deviations from this principles.

=== Classpath dependency

The first step in introducing Envers to the project is adding the
`hibernate-envers` jar to classpath. Fortunately, version *is* defined
in Spring Boot Dependencies. For example:

`pom.xml` of `org.springframework.boot:spring-boot-dependencies:3.5.5`:

----
  <properties>
    ...
    <hibernate.version>6.6.26.Final</hibernate.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      ...
      <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-envers</artifactId>
        <version>${hibernate.version}</version>
      </dependency>
----

