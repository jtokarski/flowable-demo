
== Background

=== Foreword

* initially I wanted to import dependency of `org.defendev.easygo:database` to this project and make
  research starting with pre-existing tables. But since I've discovered that Hibernate schema tooling
  offers possibility to *write DDL to script* instead of making live update, I decided to only use this.
  See `JAKARTA_HBM2DDL_SCRIPTS_ACTION` / `jakarta.persistence.schema-generation.scripts.action`

* so the main focus is *generating DDLs* from Java `@Entity` classes

* validating the database schema is secondary focus. The only goal here is to prove that
  *Envers adds its own comprehensive validations* on top of pure-Hibernate validations. When that's confirmed,
  I will know that in real projects I can write DDLs manually and use Hibernate+Envers schema validation
  as guardrail (rather than generator).

=== Use case of Hibernate Envers

I realize, that for my use of Envers is implementing the *maker-checker* process, which
is not the original purpose of Envers. This comes with some major consequences:

* the normal querying for entities *goes obsolete*. Now for all tables where I show live-version data
  for the user I have to use `AuditReader` / `AuditQuery`

* it's questionable if it still makes sense have `@CreatedDate` / `@LastModifiedDate` on the `@Entity`.
  They seem redundant because Envers already tracks the same information in `@RevisionEntity`
  and audit tables.



=== Thoughts on approach

* write multiple persistence units with isolated configuration in this single Gradle subproject

* I would like to risk to go without `@CreatedDate` / `@LastModifiedDate` fields on the `@Entity`
  and personally experience potential consequences.



== Observed features

=== General Envers principle

As described in `Hibernate_User_Guide.html`, adding Envers does not affect:

* schema of "_main_" tables

* the data persisted in "_main_" tables

I would like to catch any deviations from this principles.

=== Classpath dependency

The first step in introducing Envers to the project is adding the
`hibernate-envers` jar to classpath. Fortunately, version *is* defined
in Spring Boot Dependencies. For example:

`pom.xml` of `org.springframework.boot:spring-boot-dependencies:3.5.5`:

----
  <properties>
    ...
    <hibernate.version>6.6.26.Final</hibernate.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      ...
      <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-envers</artifactId>
        <version>${hibernate.version}</version>
      </dependency>
----

=== Indicate what to audit - using `@Audited`

Whether we want to annotate **whole class** and audit all properties
**or** annotate **only some** persistent properties:

* we use **the same** annotation - `org.hibernate.envers.Audited`.

* the `@Id` property will always be included in audit table, even if not indicated.

=== Custom `@RevisionEntity` a.k.a Revision Log

Justification:

* makes it possible to have additional columns for example with `userId` filled
  by some `RevisionListener` from `SecurityContextHolder`

* makes it possible to add `@Transient` getter for converting the `Long` unix epoch timestamp
  to `Instant` or `ZonedDateTime`

* makes it possible to adjust table name and its column names

Implementation:

* the class annotated with `@RevisionEntity` must also be annotated as `@Entity` - otherwise it's ignored

* the `@RevisionTimestamp` property have to be have to be unix epoch `Long` as specified
  in User Guide as well as `org.hibernate.envers.RevisionEntity` Javadoc. Live with it.

* just adding the `@ModifiedEntityNames` property with proper annotations enables
  the __tracking entity names modified during revisions__ - no other settings needed.

* following settings are made irrelevant (get ignored or redundant):

** `EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID`

** `EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION`

=== Audit strategy

There are two reasons for configuring `ValidityAuditStrategy` (which is not default):

* improved query performance

* **audit table partitioning** needs a column that exists within the audit table. As a rule,
  it makes sense to use either the __end revision__ or the __end revision timestamp__ column.
  So I'll need `ValidityAuditStrategy` anyway.

Implementation:

* set the `EnversSettings.AUDIT_STRATEGY` to `ValidityAuditStrategy.class.getName()`.

* adjust **end revision** field name - set `EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME`
  to `idOfEndVersioningRevision`.

* note that the **end revision** field is exclusive indication, so it complies to Dijkstra
  range boundary representation - `[REV, REVEND)`

=== Audit table partitioning

* Not sure if partitioning really requires both: __end revision__ and the __end revision timestamp__.
  Or is just __end revision__ sufficient?

* Wondering - if __end revision__ is sufficient for **partitioning** it should probably also
  work good for **old data destruction**



== Reference of Envers fields

=== `@RevisionEntity` a.k.a Revision Log table __(mandatory)__

* `@RevisionEntity` table name __(mandatory)__, default name **REVINFO**, modified by `@Table` annotation to **VersioningRevision**

* `@RevisionNumber` property __(mandatory)__, default name **REV**, modified by `@Column` annotation
  to **id**

* `@RevisionTimestamp` property __(mandatory)__, default name **REVTSTMP**, modified by `@Column` annotation to **unixEpochTimestamp**

=== `@ModifiedEntityNames` table __(optional)__

* default table name **REVCHANGES**, modified by `@JoinTable(name = ...)` annotation
  to **VersioningRevisionChanges**

* foreign key to revision id - default column name **REV**, modified by
  `@JoinTable(joinColumns = @JoinColumn(name = ...))` annotation to **idOfVersioningRevision**

* changed entity name column - default name **ENTITYNAME**, modified by
  `@Column(name = ...)` to **entityName**

=== Audit tables __(mandatory)__

* default table suffix **_AUD**, modified by JPA property `EnversSettings.AUDIT_TABLE_SUFFIX`
  to **_Audit**

* foreign key to revision id __(mandatory)__ - default column name **REV**, modified by
  JPA property `EnversSettings.REVISION_FIELD_NAME` to **idOfVersioningRevision**

* revision type __(mandatory)__ - default column name **REVTYPE**, modified by
  JPA property `EnversSettings.REVISION_TYPE_FIELD_NAME` to **versioningRevisionType**

* foreign key to end revision id __(optional)__ - default column name **REVEND**, modified by
  JPA property `EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME`
  to **idOfEndVersioningRevision**

* modified flags  - default column suffix **_MOD**, modified by JPA property
  `EnversSettings.MODIFIED_FLAG_SUFFIX` to **_Modified**


