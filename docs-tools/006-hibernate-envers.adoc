
== Background

=== Foreword

* initially I wanted to import dependency of `org.defendev.easygo:database` to this project and make
  research starting with pre-existing tables. But since I've discovered that Hibernate schema tooling
  offers possibility to *write DDL to script* instead of making live update, I decided to only use this.
  See `JAKARTA_HBM2DDL_SCRIPTS_ACTION` / `jakarta.persistence.schema-generation.scripts.action`

* so the main focus is *generating DDLs* from Java `@Entity` classes

* validating the database schema is secondary focus. The only goal here is to prove that
  *Envers adds its own comprehensive validations* on top of pure-Hibernate validations. When that's confirmed,
  I will know that in real projects I can write DDLs manually and use Hibernate+Envers schema validation
  as guardrail (rather than generator).

=== Use case of Hibernate Envers

I realize, that for my use of Envers is implementing the *maker-checker* process, which
is not the original purpose of Envers. This comes with some major consequences:

* the normal querying for entities *goes obsolete*. Now for all tables where I show live-version data
  for the user I have to use `AuditReader` / `AuditQuery`

* it's questionable if it still makes sense have `@CreatedDate` / `@LastModifiedDate` on the `@Entity`.
  They seem redundant because Envers already tracks the same information in `@RevisionEntity`
  and audit tables.

*#edit 2025-12-20*: I admit that I've made this conclusion too soon. No, I shouldn't treat the audit tables
as equally important as the main tables. I feels much more comfortable to treat the main tables
as primary source of truth and the audit tables as merely a convenience. Besides the feeling, it's also
because of my discoveries that Envers HBM2DDL generates less RDBMS constraints.

=== Thoughts on approach

* write multiple persistence units with isolated configuration in this single Gradle subproject

* I would like to risk to go without `@CreatedDate`/`@LastModifiedDate` fields on the `@Entity`
  and personally experience potential consequences.

*#edit 2025-12-20*: It's true that `@CreatedDate`/`@LastModifiedDate` fields is redundant if we have
audit and revision tables. But still it feels much more natural to have them in the live entity,
the primary source of truth that is accessible without audit readers.


== Observed features

=== General Envers principle

As described in `Hibernate_User_Guide.html`, adding Envers does not affect:

* schema of "_main_" tables

* the data persisted in "_main_" tables

I would like to catch any deviations from this principles.

=== Classpath dependency

The first step in introducing Envers to the project is adding the
`hibernate-envers` jar to classpath. Fortunately, version *is* defined
in Spring Boot Dependencies. For example:

`pom.xml` of `org.springframework.boot:spring-boot-dependencies:3.5.5`:

----
  <properties>
    ...
    <hibernate.version>6.6.26.Final</hibernate.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      ...
      <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-envers</artifactId>
        <version>${hibernate.version}</version>
      </dependency>
----

=== Indicate what to audit - using `@Audited`

Whether we want to annotate **whole class** and audit all properties
**or** annotate **only some** persistent properties:

* we use **the same** annotation - `org.hibernate.envers.Audited`.

* the `@Id` property will always be included in audit table, even if not indicated.

My preferred convention is to always put `@Audited` on entity property level, never on a class level.


=== Custom `@RevisionEntity` a.k.a Revision Log

Justification:

* makes it possible to have additional columns for example with `userId` filled
  by some `RevisionListener` from `SecurityContextHolder`

* makes it possible to add `@Transient` getter for converting the `Long` unix epoch timestamp
  to `Instant` or `ZonedDateTime`

* makes it possible to adjust *table name*, its *column names* and name of *containing schema*

Implementation:

* the class annotated with `@RevisionEntity` must also be annotated as `@Entity` - otherwise it's ignored

* the `@RevisionTimestamp` property have to be have to be unix epoch `Long` as specified
  in User Guide as well as `org.hibernate.envers.RevisionEntity` Javadoc. Live with it.

* just adding the `@ModifiedEntityNames` property with proper annotations enables
  the __tracking entity names modified during revisions__ - no other settings needed.

* following settings are made irrelevant (get ignored or redundant):

** `EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID`

** `EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION`

=== Audit strategy

There are two reasons for configuring `ValidityAuditStrategy` (which is not default):

* improved query performance

* **audit table partitioning** needs a column that exists within the audit table. As a rule,
  it makes sense to use either the __end revision__ or the __end revision timestamp__ column.
  So I'll need `ValidityAuditStrategy` anyway.

Implementation:

* set the `EnversSettings.AUDIT_STRATEGY` to `ValidityAuditStrategy.class.getName()`.

* adjust **end revision** field name - set `EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME`
  to `idOfEndEnversRevision`.

* note that the **end revision** field is exclusive indication, so it complies to Dijkstra
  range boundary representation - `[REV, REVEND)`

=== Tracking entity names modified during revisions

Done already in custom `@RevisionEntity`.

*(!) Note:* in maker-checker scenario, with conditional-auditing based on
explicit *lastMarkForAuditZulu*, it seems that enabling this feature
is pointless.

=== Tracking entity changes at the property level

It is extension of the previous point. Done by `@Audited(withModifiedFlag = true)` on each field.

*(!) Note:* Unfortunately the modified-flags don't work conditional-auditing as
expected. *They only capture most recent change*, not all changes since last audit.
Therefore I'm disabling this feature.

=== Conditional auditing

It's possible to skip revisions based on `@Basic` properties. A drawback is that for
related collection changes - seems too tricky to think about it.

Implemented as described in
https://thorben-janssen.com/conditional-auditing-hibernate-envers/[Thorben Janssen - How to Implement Conditional Auditing with Hibernate Envers]

*#edit 2025-12-20*: After some experimentation, the conclusion is that conditional auditing
is leaky and risky concept. It brings too much uncertainty about the future accessibility of
necessary audit data. In order to optimize the usage of persistent storage the following should
be considered instead:

* develop reliable scripts for accurate selection and deletion of irrelevant revisions
  and audit table entries

* develop reliable script for outdated data destruction

* learn RDBMS-level table partitioning features


=== Audit table partitioning

* Not sure if partitioning really requires both: __end revision__ and the __end revision timestamp__.
  Or is just __end revision__ sufficient?

* Wondering - if __end revision__ is sufficient for **partitioning** it should probably also
  work good for **old data destruction**

* In any case, the *Audit table partitioning* is not a feature built into Envers or Hibernate.
  It's something you do on the RDBMS level manipulating per-table storage settings.


== Reference of Envers fields

=== `@RevisionEntity` a.k.a Revision Log table __(mandatory)__

* `@RevisionEntity` table name __(mandatory)__, default name **REVINFO**, modified by `@Table` annotation to **EnversRevision**

* `@RevisionNumber` property __(mandatory)__, default name **REV**, modified by `@Column` annotation
  to **id**

* `@RevisionTimestamp` property __(mandatory)__, default name **REVTSTMP**, modified by `@Column` annotation to **unixEpochTimestamp**

=== `@ModifiedEntityNames` table __(optional)__

* default table name **REVCHANGES**, modified by `@JoinTable(name = ...)` annotation
  to **EnversRevisionChanges**

* foreign key to revision id - default column name **REV**, modified by
  `@JoinTable(joinColumns = @JoinColumn(name = ...))` annotation to **idOfEnversRevision**

* changed entity name column - default name **ENTITYNAME**, modified by
  `@Column(name = ...)` to **entityName**

=== Audit tables __(mandatory)__

* default table suffix **_AUD**, modified by JPA property `EnversSettings.AUDIT_TABLE_SUFFIX`
  to **_Audit**

* foreign key to revision id __(mandatory)__ - default column name **REV**, modified by
  JPA property `EnversSettings.REVISION_FIELD_NAME` to **idOfEnversRevision**

* revision type __(mandatory)__ - default column name **REVTYPE**, modified by
  JPA property `EnversSettings.REVISION_TYPE_FIELD_NAME` to **enversRevisionType**

* foreign key to end revision id __(optional)__ - default column name **REVEND**, modified by
  JPA property `EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME`
  to **idOfEndEnversRevision**

* modified flags  - default column suffix **_MOD**, modified by JPA property
  `EnversSettings.MODIFIED_FLAG_SUFFIX` to **_Modified**


== For future research

=== Nullable `REVTYPE`

Envers HBM2DDL generates audit tables where the `REVTYPE` (`enversRevisionType`) doesn't have
the NOT NULL constraint. I that even possible that audit table row has `NULL` in this column?
Can I add NOT NULL myself and see if it would ever cause a problem?


== Conclusions

=== Foreign Keys trade-off

When having entities related through foreign key constraints, in audit tables the foreign keys constraints
are no longer there (not created by Envers HBM2DDL). Not sure why.
Can I add those constraints myself and see if it would ever cause a problem?

=== Schema evolution trade-off

The evolution of schema can't be avoided. So, along with main tables, the audit tables
will have to evolve as well. On the other hand, by principle, I should treat audit tables
as unmodifiable. This conceptual conflict is unavoidable.


