
== Implementation

=== Why custom `@RevisionEntity`?

* most likely the primary reason was the *imposed convention* of database objects naming.

* also, in the `@RevisionEntity` table we've had additional columns for `user_id` and
   `user_role` that were filled from thread-local security context by custom
   `RevisionListener`


== Issues with Hibernate Envers

I recall following issues with Envers-based maker-checker implemented for Ycorpo project:

* an `@Entity` was always in state of most recent update, which may be live or pending change.
  Therefore, querying, listing, sorting, pagination of live version involved revision queries.

* the *reject changes* functionality involved restoring previous revision, which
  wasn't trivial to find and apply the diff. It also felt a little unreliable - instead
  of just discarding changes we were really reproducing recent live state. It would be better
  if a live `@Entity` wasn't touched at all.

* in case of editing `@Entity` - only one working copy is possible

* showing approved changes (diff) in audit view was not trivial

* multiple changes between live versions created multi-revision gaps. We needed to handle this complexity.

* and above it all - the dynamic attribute concept with some design mistake introduced additional complexity